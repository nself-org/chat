/**
 * Album Management System
 *
 * Provides album creation, auto-album generation, custom albums,
 * album sharing, and album-based media organization.
 *
 * Auto-albums are generated from media metadata (by date, type, channel).
 * Custom albums are user-created collections.
 */

import type { MediaItem, MediaType } from './media-types'
import { getFileCategory } from './media-parity'

// ============================================================================
// Types
// ============================================================================

export type AlbumType =
  | 'custom'       // User-created album
  | 'auto-date'    // Auto-generated by date (month)
  | 'auto-type'    // Auto-generated by file type
  | 'auto-channel' // Auto-generated by channel
  | 'shared'       // Album shared with/by another user
  | 'favorites'    // Favorite items album

export type AlbumSortBy =
  | 'name_asc'
  | 'name_desc'
  | 'date_asc'
  | 'date_desc'
  | 'item_count_asc'
  | 'item_count_desc'

export type AlbumVisibility = 'private' | 'channel' | 'public'

export interface Album {
  id: string
  name: string
  description: string
  type: AlbumType
  itemIds: string[]
  itemCount: number
  coverItemId: string | null
  createdBy: string
  channelId: string | null
  visibility: AlbumVisibility
  createdAt: Date
  updatedAt: Date
  /** Auto-album metadata key (e.g., "2026-01" for monthly, "image" for type) */
  autoKey: string | null
  /** Tags for categorization */
  tags: string[]
  /** Whether album is pinned for quick access */
  isPinned: boolean
}

export interface AlbumShareConfig {
  albumId: string
  sharedWith: string[] // User IDs
  sharedBy: string
  expiresAt: Date | null
  allowDownload: boolean
  allowAddItems: boolean
  password: string | null
}

export interface AlbumCreateOptions {
  name: string
  description?: string
  type: AlbumType
  itemIds?: string[]
  createdBy: string
  channelId?: string
  visibility?: AlbumVisibility
  coverItemId?: string | null
  tags?: string[]
}

export interface AlbumStats {
  totalItems: number
  totalSize: number
  typeBreakdown: Record<string, number>
  dateRange: { earliest: Date | null; latest: Date | null }
  uniqueSenders: number
}

// ============================================================================
// Constants
// ============================================================================

const ALBUM_ID_PREFIX = 'album_'
const AUTO_ALBUM_MIN_ITEMS = 2
const MAX_ALBUM_NAME_LENGTH = 128
const MAX_ALBUM_DESCRIPTION_LENGTH = 500
const MAX_TAGS_PER_ALBUM = 20

// ============================================================================
// Album Creation
// ============================================================================

let albumIdCounter = 0

/**
 * Generate a unique album ID
 */
export function generateAlbumId(): string {
  albumIdCounter++
  return `${ALBUM_ID_PREFIX}${Date.now()}_${albumIdCounter}`
}

/**
 * Create a new album
 */
export function createAlbum(options: AlbumCreateOptions): Album {
  const name = options.name.trim().slice(0, MAX_ALBUM_NAME_LENGTH)
  const description = (options.description || '').trim().slice(0, MAX_ALBUM_DESCRIPTION_LENGTH)
  const tags = (options.tags || []).slice(0, MAX_TAGS_PER_ALBUM)

  if (!name) {
    throw new Error('Album name is required')
  }

  const now = new Date()

  return {
    id: generateAlbumId(),
    name,
    description,
    type: options.type,
    itemIds: options.itemIds || [],
    itemCount: options.itemIds?.length || 0,
    coverItemId: options.coverItemId ?? (options.itemIds?.[0] || null),
    createdBy: options.createdBy,
    channelId: options.channelId || null,
    visibility: options.visibility || 'private',
    createdAt: now,
    updatedAt: now,
    autoKey: null,
    tags,
    isPinned: false,
  }
}

/**
 * Update an album's metadata
 */
export function updateAlbum(
  album: Album,
  updates: Partial<Pick<Album, 'name' | 'description' | 'visibility' | 'coverItemId' | 'tags' | 'isPinned'>>
): Album {
  return {
    ...album,
    ...updates,
    name: updates.name?.trim().slice(0, MAX_ALBUM_NAME_LENGTH) || album.name,
    description: updates.description !== undefined
      ? updates.description.trim().slice(0, MAX_ALBUM_DESCRIPTION_LENGTH)
      : album.description,
    tags: updates.tags?.slice(0, MAX_TAGS_PER_ALBUM) || album.tags,
    updatedAt: new Date(),
  }
}

/**
 * Delete albums by IDs
 */
export function deleteAlbums(albums: Album[], idsToDelete: string[]): Album[] {
  const deleteSet = new Set(idsToDelete)
  return albums.filter((album) => !deleteSet.has(album.id))
}

// ============================================================================
// Auto-Album Generation
// ============================================================================

/**
 * Create auto-albums from media items
 * Generates albums grouped by month, type, and channel
 */
export function createAutoAlbums(
  items: MediaItem[],
  channelId?: string
): Album[] {
  const albums: Album[] = []

  // Generate monthly albums
  albums.push(...createMonthlyAlbums(items, channelId))

  // Generate type-based albums
  albums.push(...createTypeAlbums(items, channelId))

  // Generate channel-based albums (only if no specific channel filter)
  if (!channelId) {
    albums.push(...createChannelAlbums(items))
  }

  return albums
}

/**
 * Create albums grouped by month
 */
export function createMonthlyAlbums(
  items: MediaItem[],
  channelId?: string
): Album[] {
  const monthGroups = new Map<string, MediaItem[]>()

  for (const item of items) {
    const date = new Date(item.createdAt)
    const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`
    if (!monthGroups.has(key)) {
      monthGroups.set(key, [])
    }
    monthGroups.get(key)!.push(item)
  }

  const albums: Album[] = []
  for (const [key, groupItems] of monthGroups) {
    if (groupItems.length < AUTO_ALBUM_MIN_ITEMS) continue

    const [year, month] = key.split('-')
    const date = new Date(parseInt(year), parseInt(month) - 1, 1)
    const name = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long' })

    const album: Album = {
      id: generateAlbumId(),
      name,
      description: `Media from ${name}`,
      type: 'auto-date',
      itemIds: groupItems.map((i) => i.id),
      itemCount: groupItems.length,
      coverItemId: findBestCoverItem(groupItems),
      createdBy: 'system',
      channelId: channelId || null,
      visibility: 'channel',
      createdAt: date,
      updatedAt: new Date(),
      autoKey: key,
      tags: ['auto', 'monthly'],
      isPinned: false,
    }

    albums.push(album)
  }

  // Sort by date descending (most recent first)
  albums.sort((a, b) => (b.autoKey || '').localeCompare(a.autoKey || ''))

  return albums
}

/**
 * Create albums grouped by media type
 */
export function createTypeAlbums(
  items: MediaItem[],
  channelId?: string
): Album[] {
  const typeGroups = new Map<MediaType, MediaItem[]>()

  for (const item of items) {
    if (!typeGroups.has(item.fileType)) {
      typeGroups.set(item.fileType, [])
    }
    typeGroups.get(item.fileType)!.push(item)
  }

  const albums: Album[] = []
  const typeLabels: Record<string, string> = {
    image: 'Images',
    video: 'Videos',
    audio: 'Audio Files',
    document: 'Documents',
    archive: 'Archives',
    other: 'Other Files',
  }

  for (const [type, groupItems] of typeGroups) {
    if (groupItems.length < AUTO_ALBUM_MIN_ITEMS) continue

    const album: Album = {
      id: generateAlbumId(),
      name: typeLabels[type] || `${type} Files`,
      description: `All ${typeLabels[type]?.toLowerCase() || type} files`,
      type: 'auto-type',
      itemIds: groupItems.map((i) => i.id),
      itemCount: groupItems.length,
      coverItemId: findBestCoverItem(groupItems),
      createdBy: 'system',
      channelId: channelId || null,
      visibility: 'channel',
      createdAt: new Date(),
      updatedAt: new Date(),
      autoKey: type,
      tags: ['auto', 'type', type],
      isPinned: false,
    }

    albums.push(album)
  }

  return albums
}

/**
 * Create albums grouped by channel
 */
export function createChannelAlbums(items: MediaItem[]): Album[] {
  const channelGroups = new Map<string, { name: string; items: MediaItem[] }>()

  for (const item of items) {
    const channelId = item.channelId || 'unknown'
    if (!channelGroups.has(channelId)) {
      channelGroups.set(channelId, {
        name: item.channelName || `Channel ${channelId}`,
        items: [],
      })
    }
    channelGroups.get(channelId)!.items.push(item)
  }

  const albums: Album[] = []
  for (const [channelId, group] of channelGroups) {
    if (group.items.length < AUTO_ALBUM_MIN_ITEMS) continue

    const album: Album = {
      id: generateAlbumId(),
      name: group.name,
      description: `Media from ${group.name}`,
      type: 'auto-channel',
      itemIds: group.items.map((i) => i.id),
      itemCount: group.items.length,
      coverItemId: findBestCoverItem(group.items),
      createdBy: 'system',
      channelId,
      visibility: 'channel',
      createdAt: new Date(),
      updatedAt: new Date(),
      autoKey: channelId,
      tags: ['auto', 'channel'],
      isPinned: false,
    }

    albums.push(album)
  }

  return albums
}

/**
 * Create a favorites album
 */
export function createFavoritesAlbum(
  items: MediaItem[],
  userId: string
): Album {
  const favoriteItems = items.filter((item) => item.isFavorite)

  return {
    id: generateAlbumId(),
    name: 'Favorites',
    description: 'Your favorite media items',
    type: 'favorites',
    itemIds: favoriteItems.map((i) => i.id),
    itemCount: favoriteItems.length,
    coverItemId: findBestCoverItem(favoriteItems),
    createdBy: userId,
    channelId: null,
    visibility: 'private',
    createdAt: new Date(),
    updatedAt: new Date(),
    autoKey: 'favorites',
    tags: ['favorites'],
    isPinned: true,
  }
}

// ============================================================================
// Album Sorting & Filtering
// ============================================================================

/**
 * Sort albums by the specified criteria
 */
export function sortAlbums(albums: Album[], sortBy: AlbumSortBy): Album[] {
  const sorted = [...albums]

  sorted.sort((a, b) => {
    switch (sortBy) {
      case 'name_asc':
        return a.name.localeCompare(b.name)
      case 'name_desc':
        return b.name.localeCompare(a.name)
      case 'date_asc':
        return a.createdAt.getTime() - b.createdAt.getTime()
      case 'date_desc':
        return b.createdAt.getTime() - a.createdAt.getTime()
      case 'item_count_asc':
        return a.itemCount - b.itemCount
      case 'item_count_desc':
        return b.itemCount - a.itemCount
      default:
        return 0
    }
  })

  // Pinned albums always come first
  return sorted.sort((a, b) => {
    if (a.isPinned && !b.isPinned) return -1
    if (!a.isPinned && b.isPinned) return 1
    return 0
  })
}

/**
 * Filter albums by type
 */
export function filterAlbumsByType(albums: Album[], types: AlbumType[]): Album[] {
  return albums.filter((album) => types.includes(album.type))
}

/**
 * Filter albums by visibility
 */
export function filterAlbumsByVisibility(
  albums: Album[],
  visibility: AlbumVisibility
): Album[] {
  return albums.filter((album) => album.visibility === visibility)
}

/**
 * Filter albums by tag
 */
export function filterAlbumsByTag(albums: Album[], tag: string): Album[] {
  return albums.filter((album) => album.tags.includes(tag))
}

/**
 * Search albums by name
 */
export function searchAlbums(albums: Album[], query: string): Album[] {
  if (!query.trim()) return albums
  const normalizedQuery = query.toLowerCase()
  return albums.filter(
    (album) =>
      album.name.toLowerCase().includes(normalizedQuery) ||
      album.description.toLowerCase().includes(normalizedQuery) ||
      album.tags.some((tag) => tag.toLowerCase().includes(normalizedQuery))
  )
}

// ============================================================================
// Album Statistics
// ============================================================================

/**
 * Get statistics for an album
 */
export function getAlbumStats(
  album: Album,
  allItems: MediaItem[]
): AlbumStats {
  const itemIdSet = new Set(album.itemIds)
  const albumItems = allItems.filter((item) => itemIdSet.has(item.id))

  const typeBreakdown: Record<string, number> = {}
  const senders = new Set<string>()
  let totalSize = 0
  let earliest: Date | null = null
  let latest: Date | null = null

  for (const item of albumItems) {
    typeBreakdown[item.fileType] = (typeBreakdown[item.fileType] || 0) + 1
    senders.add(item.uploadedBy.id)
    totalSize += item.fileSize

    const date = new Date(item.createdAt)
    if (!earliest || date < earliest) earliest = date
    if (!latest || date > latest) latest = date
  }

  return {
    totalItems: albumItems.length,
    totalSize,
    typeBreakdown,
    dateRange: { earliest, latest },
    uniqueSenders: senders.size,
  }
}

// ============================================================================
// Album Sharing
// ============================================================================

/**
 * Create a share configuration for an album
 */
export function createAlbumShare(
  albumId: string,
  sharedBy: string,
  sharedWith: string[],
  options?: {
    expiresAt?: Date | null
    allowDownload?: boolean
    allowAddItems?: boolean
    password?: string | null
  }
): AlbumShareConfig {
  return {
    albumId,
    sharedBy,
    sharedWith,
    expiresAt: options?.expiresAt ?? null,
    allowDownload: options?.allowDownload ?? true,
    allowAddItems: options?.allowAddItems ?? false,
    password: options?.password ?? null,
  }
}

/**
 * Check if a share is expired
 */
export function isShareExpired(share: AlbumShareConfig): boolean {
  if (!share.expiresAt) return false
  return new Date() > share.expiresAt
}

/**
 * Check if a user has access to a shared album
 */
export function hasShareAccess(
  share: AlbumShareConfig,
  userId: string
): boolean {
  if (isShareExpired(share)) return false
  return share.sharedWith.includes(userId) || share.sharedBy === userId
}

// ============================================================================
// Album Merge & Utilities
// ============================================================================

/**
 * Merge two albums into one
 */
export function mergeAlbums(
  albumA: Album,
  albumB: Album,
  mergedName?: string
): Album {
  const combinedIds = [...new Set([...albumA.itemIds, ...albumB.itemIds])]

  return {
    id: generateAlbumId(),
    name: mergedName || `${albumA.name} + ${albumB.name}`,
    description: `Merged from "${albumA.name}" and "${albumB.name}"`,
    type: 'custom',
    itemIds: combinedIds,
    itemCount: combinedIds.length,
    coverItemId: albumA.coverItemId || albumB.coverItemId,
    createdBy: albumA.createdBy,
    channelId: albumA.channelId === albumB.channelId ? albumA.channelId : null,
    visibility: 'private',
    createdAt: new Date(),
    updatedAt: new Date(),
    autoKey: null,
    tags: [...new Set([...albumA.tags, ...albumB.tags])],
    isPinned: false,
  }
}

/**
 * Duplicate an album
 */
export function duplicateAlbum(album: Album, newName?: string): Album {
  return {
    ...album,
    id: generateAlbumId(),
    name: newName || `${album.name} (Copy)`,
    type: 'custom',
    createdAt: new Date(),
    updatedAt: new Date(),
    autoKey: null,
    isPinned: false,
  }
}

/**
 * Find the best cover item from a list of media items
 * Prefers images, then videos, then most recent
 */
export function findBestCoverItem(items: MediaItem[]): string | null {
  if (items.length === 0) return null

  // Prefer images
  const images = items.filter((i) => i.fileType === 'image')
  if (images.length > 0) {
    // Return the most recent image
    return images.sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )[0].id
  }

  // Then videos
  const videos = items.filter((i) => i.fileType === 'video')
  if (videos.length > 0) {
    return videos.sort(
      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )[0].id
  }

  // Fallback to most recent item
  return items.sort(
    (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  )[0].id
}

/**
 * Get candidate items for album covers
 */
export function getAlbumCoverCandidates(
  album: Album,
  allItems: MediaItem[],
  limit: number = 6
): MediaItem[] {
  const itemIdSet = new Set(album.itemIds)
  const albumItems = allItems.filter((item) => itemIdSet.has(item.id))

  // Prioritize images and videos for cover candidates
  const sorted = albumItems.sort((a, b) => {
    const typePriority: Record<string, number> = { image: 0, video: 1, audio: 2, document: 3, archive: 4, other: 5 }
    const aPri = typePriority[a.fileType] ?? 5
    const bPri = typePriority[b.fileType] ?? 5
    if (aPri !== bPri) return aPri - bPri
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  })

  return sorted.slice(0, limit)
}

/**
 * Validate album name
 */
export function validateAlbumName(name: string): { valid: boolean; error?: string } {
  const trimmed = name.trim()

  if (!trimmed) {
    return { valid: false, error: 'Album name is required' }
  }

  if (trimmed.length > MAX_ALBUM_NAME_LENGTH) {
    return { valid: false, error: `Album name must be ${MAX_ALBUM_NAME_LENGTH} characters or less` }
  }

  // Check for forbidden characters
  if (/[<>:"/\\|?*]/.test(trimmed)) {
    return { valid: false, error: 'Album name contains invalid characters' }
  }

  return { valid: true }
}
