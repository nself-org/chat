/**
 * Vulnerability Tracker and Remediation Manager
 *
 * Provides tracking, prioritization, and management of security vulnerabilities
 * across SAST, DAST, and SCA findings with remediation workflows.
 *
 * @module lib/security/vulnerability-tracker
 */

import type { SASTFinding, Severity } from './sast-scanner'
import type { DependencyVulnerability, VulnerabilitySeverity } from './dependency-scanner'

// ============================================================================
// Types
// ============================================================================

/**
 * Unified severity type across all scanners
 */
export type UnifiedSeverity = 'critical' | 'high' | 'medium' | 'low' | 'info'

/**
 * Source of the vulnerability finding
 */
export type VulnerabilitySource = 'sast' | 'dast' | 'sca' | 'manual' | 'pentest' | 'bugbounty'

/**
 * Status of vulnerability remediation
 */
export type VulnerabilityStatus =
  | 'open'
  | 'acknowledged'
  | 'in_progress'
  | 'fixed'
  | 'verified'
  | 'false_positive'
  | 'accepted_risk'
  | 'wont_fix'

/**
 * Priority for remediation
 */
export type RemediationPriority = 'critical' | 'high' | 'medium' | 'low'

/**
 * A tracked vulnerability
 */
export interface TrackedVulnerability {
  id: string
  source: VulnerabilitySource
  severity: UnifiedSeverity
  status: VulnerabilityStatus
  priority: RemediationPriority
  title: string
  description: string
  location: {
    file?: string
    line?: number
    column?: number
    package?: string
    version?: string
    url?: string
  }
  identifiers: {
    cve?: string
    cwe?: string[]
    owasp?: string
    ruleId?: string
    advisoryId?: string
  }
  remediation: {
    recommendation: string
    effort?: 'trivial' | 'small' | 'medium' | 'large' | 'unknown'
    dueDate?: Date
    assignee?: string
    fixedIn?: string
    patchAvailable?: boolean
  }
  metadata: {
    hash: string
    firstSeen: Date
    lastSeen: Date
    scanId?: string
    suppressed?: boolean
    suppressedBy?: string
    suppressedAt?: Date
    suppressionReason?: string
    tags?: string[]
    notes?: string[]
  }
  history: VulnerabilityHistoryEntry[]
}

/**
 * History entry for vulnerability status changes
 */
export interface VulnerabilityHistoryEntry {
  timestamp: Date
  action: VulnerabilityAction
  previousStatus?: VulnerabilityStatus
  newStatus?: VulnerabilityStatus
  actor?: string
  comment?: string
}

/**
 * Actions that can be taken on a vulnerability
 */
export type VulnerabilityAction =
  | 'created'
  | 'status_changed'
  | 'assigned'
  | 'unassigned'
  | 'priority_changed'
  | 'suppressed'
  | 'unsuppressed'
  | 'commented'
  | 'tagged'
  | 'due_date_set'

/**
 * Query options for vulnerabilities
 */
export interface VulnerabilityQuery {
  source?: VulnerabilitySource[]
  severity?: UnifiedSeverity[]
  status?: VulnerabilityStatus[]
  priority?: RemediationPriority[]
  assignee?: string
  tags?: string[]
  file?: string
  package?: string
  cve?: string
  cwe?: string
  startDate?: Date
  endDate?: Date
  suppressed?: boolean
  limit?: number
  offset?: number
  sortBy?: 'severity' | 'priority' | 'firstSeen' | 'lastSeen' | 'dueDate'
  sortOrder?: 'asc' | 'desc'
}

/**
 * Result of a vulnerability query
 */
export interface VulnerabilityQueryResult {
  vulnerabilities: TrackedVulnerability[]
  total: number
  hasMore: boolean
}

/**
 * Statistics about tracked vulnerabilities
 */
export interface VulnerabilityStats {
  total: number
  bySeverity: Record<UnifiedSeverity, number>
  byStatus: Record<VulnerabilityStatus, number>
  bySource: Record<VulnerabilitySource, number>
  byPriority: Record<RemediationPriority, number>
  meanTimeToRemediation?: number
  oldestOpen?: Date
  overdueCount: number
  suppressedCount: number
}

/**
 * Remediation policy configuration
 */
export interface RemediationPolicy {
  /** Block merge if critical/high vulnerabilities exist */
  blockOnCritical: boolean
  blockOnHigh: boolean
  /** Maximum allowed vulnerabilities by severity */
  maxAllowed: {
    critical: number
    high: number
    medium: number
    low: number
  }
  /** Required remediation SLAs in days */
  sla: {
    critical: number
    high: number
    medium: number
    low: number
  }
  /** Auto-suppress duplicates */
  autoSuppressDuplicates: boolean
  /** Require justification for accepting risk */
  requireRiskAcceptanceJustification: boolean
  /** Notify on new vulnerabilities */
  notifyOnNew: boolean
  /** Notify on overdue */
  notifyOnOverdue: boolean
}

/**
 * Configuration for the vulnerability tracker
 */
export interface VulnerabilityTrackerConfig {
  /** Remediation policy */
  policy?: Partial<RemediationPolicy>
  /** Maximum vulnerabilities to track */
  maxVulnerabilities?: number
  /** Enable persistence callbacks */
  onPersist?: (vulnerability: TrackedVulnerability) => Promise<void>
  onDelete?: (id: string) => Promise<void>
}

// ============================================================================
// Default Policy
// ============================================================================

/**
 * Default remediation policy
 */
export const DEFAULT_REMEDIATION_POLICY: RemediationPolicy = {
  blockOnCritical: true,
  blockOnHigh: true,
  maxAllowed: {
    critical: 0,
    high: 0,
    medium: 10,
    low: 50,
  },
  sla: {
    critical: 1, // 1 day
    high: 7, // 7 days
    medium: 30, // 30 days
    low: 90, // 90 days
  },
  autoSuppressDuplicates: true,
  requireRiskAcceptanceJustification: true,
  notifyOnNew: true,
  notifyOnOverdue: true,
}

// ============================================================================
// Severity Utilities
// ============================================================================

const SEVERITY_ORDER: Record<UnifiedSeverity, number> = {
  critical: 5,
  high: 4,
  medium: 3,
  low: 2,
  info: 1,
}

const PRIORITY_ORDER: Record<RemediationPriority, number> = {
  critical: 4,
  high: 3,
  medium: 2,
  low: 1,
}

/**
 * Convert dependency severity to unified severity
 */
function normalizeDepSeverity(severity: VulnerabilitySeverity): UnifiedSeverity {
  switch (severity) {
    case 'critical':
      return 'critical'
    case 'high':
      return 'high'
    case 'moderate':
      return 'medium'
    case 'low':
      return 'low'
    case 'info':
      return 'info'
    default:
      return 'info'
  }
}

/**
 * Determine priority based on severity and other factors
 */
function determinePriority(
  severity: UnifiedSeverity,
  hasExploit?: boolean,
  isExposed?: boolean
): RemediationPriority {
  // Critical always gets critical priority
  if (severity === 'critical') return 'critical'

  // High with exploit or exposure gets critical priority
  if (severity === 'high' && (hasExploit || isExposed)) return 'critical'
  if (severity === 'high') return 'high'

  // Medium with exploit gets high priority
  if (severity === 'medium' && hasExploit) return 'high'
  if (severity === 'medium') return 'medium'

  return 'low'
}

// ============================================================================
// Vulnerability Tracker Implementation
// ============================================================================

/**
 * Generate unique vulnerability ID
 */
function generateVulnId(): string {
  return `vuln-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
}

/**
 * Generate hash for deduplication
 */
function generateVulnHash(
  source: VulnerabilitySource,
  ruleId: string | undefined,
  file: string | undefined,
  line: number | undefined,
  packageName: string | undefined
): string {
  const data = `${source}:${ruleId ?? ''}:${file ?? ''}:${line ?? ''}:${packageName ?? ''}`
  let hash = 0
  for (let i = 0; i < data.length; i++) {
    const char = data.charCodeAt(i)
    hash = (hash << 5) - hash + char
    hash = hash & hash
  }
  return Math.abs(hash).toString(16).padStart(8, '0')
}

/**
 * Vulnerability Tracker class
 */
export class VulnerabilityTracker {
  private vulnerabilities: Map<string, TrackedVulnerability> = new Map()
  private hashIndex: Map<string, string> = new Map() // hash -> id
  private policy: RemediationPolicy
  private config: VulnerabilityTrackerConfig

  constructor(config: VulnerabilityTrackerConfig = {}) {
    this.config = {
      maxVulnerabilities: config.maxVulnerabilities ?? 10000,
      onPersist: config.onPersist,
      onDelete: config.onDelete,
    }
    this.policy = {
      ...DEFAULT_REMEDIATION_POLICY,
      ...config.policy,
    }
  }

  // -------------------------------------------------------------------------
  // Import Methods
  // -------------------------------------------------------------------------

  /**
   * Import a SAST finding
   */
  importSASTFinding(finding: SASTFinding, scanId?: string): TrackedVulnerability {
    const hash = generateVulnHash('sast', finding.ruleId, finding.file, finding.line, undefined)

    // Check for existing
    const existingId = this.hashIndex.get(hash)
    if (existingId) {
      const existing = this.vulnerabilities.get(existingId)!
      existing.metadata.lastSeen = new Date()
      existing.metadata.scanId = scanId
      return existing
    }

    const vuln: TrackedVulnerability = {
      id: generateVulnId(),
      source: 'sast',
      severity: finding.severity as UnifiedSeverity,
      status: 'open',
      priority: determinePriority(finding.severity as UnifiedSeverity),
      title: finding.ruleName,
      description: finding.description,
      location: {
        file: finding.file,
        line: finding.line,
        column: finding.column,
      },
      identifiers: {
        cwe: finding.cwe ? [finding.cwe] : undefined,
        owasp: finding.owasp,
        ruleId: finding.ruleId,
      },
      remediation: {
        recommendation: finding.remediation,
        effort: 'unknown',
      },
      metadata: {
        hash,
        firstSeen: new Date(),
        lastSeen: new Date(),
        scanId,
        suppressed: false,
        tags: [finding.category],
      },
      history: [
        {
          timestamp: new Date(),
          action: 'created',
          newStatus: 'open',
        },
      ],
    }

    this.addVulnerability(vuln)
    return vuln
  }

  /**
   * Import a dependency vulnerability
   */
  importDependencyVulnerability(
    vuln: DependencyVulnerability,
    scanId?: string
  ): TrackedVulnerability {
    const hash = generateVulnHash('sca', vuln.advisoryId, undefined, undefined, vuln.packageName)

    // Check for existing
    const existingId = this.hashIndex.get(hash)
    if (existingId) {
      const existing = this.vulnerabilities.get(existingId)!
      existing.metadata.lastSeen = new Date()
      existing.metadata.scanId = scanId
      return existing
    }

    const severity = normalizeDepSeverity(vuln.severity)

    const tracked: TrackedVulnerability = {
      id: generateVulnId(),
      source: 'sca',
      severity,
      status: 'open',
      priority: determinePriority(severity, false, true),
      title: vuln.title,
      description: vuln.description,
      location: {
        package: vuln.packageName,
        version: vuln.packageVersion,
      },
      identifiers: {
        cve: vuln.cve,
        cwe: vuln.cwe,
        advisoryId: vuln.advisoryId,
      },
      remediation: {
        recommendation: vuln.recommendation,
        fixedIn: vuln.patchedVersions,
        patchAvailable: !!vuln.patchedVersions,
        effort: vuln.patchedVersions ? 'small' : 'medium',
      },
      metadata: {
        hash,
        firstSeen: new Date(),
        lastSeen: new Date(),
        scanId,
        suppressed: false,
      },
      history: [
        {
          timestamp: new Date(),
          action: 'created',
          newStatus: 'open',
        },
      ],
    }

    this.addVulnerability(tracked)
    return tracked
  }

  /**
   * Import a manual finding
   */
  importManualFinding(params: {
    title: string
    description: string
    severity: UnifiedSeverity
    source?: VulnerabilitySource
    location?: TrackedVulnerability['location']
    identifiers?: TrackedVulnerability['identifiers']
    remediation?: Partial<TrackedVulnerability['remediation']>
    tags?: string[]
  }): TrackedVulnerability {
    const source = params.source ?? 'manual'
    const hash = generateVulnHash(
      source,
      params.identifiers?.ruleId,
      params.location?.file,
      params.location?.line,
      params.location?.package
    )

    const vuln: TrackedVulnerability = {
      id: generateVulnId(),
      source,
      severity: params.severity,
      status: 'open',
      priority: determinePriority(params.severity),
      title: params.title,
      description: params.description,
      location: params.location ?? {},
      identifiers: params.identifiers ?? {},
      remediation: {
        recommendation: params.remediation?.recommendation ?? 'See description for remediation steps',
        ...params.remediation,
      },
      metadata: {
        hash,
        firstSeen: new Date(),
        lastSeen: new Date(),
        suppressed: false,
        tags: params.tags,
      },
      history: [
        {
          timestamp: new Date(),
          action: 'created',
          newStatus: 'open',
        },
      ],
    }

    this.addVulnerability(vuln)
    return vuln
  }

  // -------------------------------------------------------------------------
  // Status Management
  // -------------------------------------------------------------------------

  /**
   * Update vulnerability status
   */
  updateStatus(
    id: string,
    status: VulnerabilityStatus,
    actor?: string,
    comment?: string
  ): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    const previousStatus = vuln.status

    // Validate status transition
    if (!this.isValidStatusTransition(previousStatus, status)) {
      throw new Error(`Invalid status transition from ${previousStatus} to ${status}`)
    }

    vuln.status = status
    vuln.history.push({
      timestamp: new Date(),
      action: 'status_changed',
      previousStatus,
      newStatus: status,
      actor,
      comment,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Assign vulnerability to a user
   */
  assignTo(id: string, assignee: string, actor?: string): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    vuln.remediation.assignee = assignee
    vuln.history.push({
      timestamp: new Date(),
      action: 'assigned',
      actor,
      comment: `Assigned to ${assignee}`,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Set due date for remediation
   */
  setDueDate(id: string, dueDate: Date, actor?: string): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    vuln.remediation.dueDate = dueDate
    vuln.history.push({
      timestamp: new Date(),
      action: 'due_date_set',
      actor,
      comment: `Due date set to ${dueDate.toISOString()}`,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Suppress a vulnerability (mark as false positive or accepted risk)
   */
  suppress(
    id: string,
    reason: string,
    status: 'false_positive' | 'accepted_risk' | 'wont_fix',
    actor: string
  ): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    // Require justification for accepted risk if policy requires it
    if (status === 'accepted_risk' && this.policy.requireRiskAcceptanceJustification && !reason) {
      throw new Error('Justification required for accepting risk')
    }

    const previousStatus = vuln.status
    vuln.status = status
    vuln.metadata.suppressed = true
    vuln.metadata.suppressedBy = actor
    vuln.metadata.suppressedAt = new Date()
    vuln.metadata.suppressionReason = reason

    vuln.history.push({
      timestamp: new Date(),
      action: 'suppressed',
      previousStatus,
      newStatus: status,
      actor,
      comment: reason,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Unsuppress a vulnerability
   */
  unsuppress(id: string, actor: string): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    const previousStatus = vuln.status
    vuln.status = 'open'
    vuln.metadata.suppressed = false
    vuln.metadata.suppressedBy = undefined
    vuln.metadata.suppressedAt = undefined
    vuln.metadata.suppressionReason = undefined

    vuln.history.push({
      timestamp: new Date(),
      action: 'unsuppressed',
      previousStatus,
      newStatus: 'open',
      actor,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Add a note to a vulnerability
   */
  addNote(id: string, note: string, actor?: string): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    if (!vuln.metadata.notes) {
      vuln.metadata.notes = []
    }

    vuln.metadata.notes.push(`[${new Date().toISOString()}] ${actor ?? 'System'}: ${note}`)

    vuln.history.push({
      timestamp: new Date(),
      action: 'commented',
      actor,
      comment: note,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  /**
   * Add tags to a vulnerability
   */
  addTags(id: string, tags: string[], actor?: string): TrackedVulnerability | null {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return null

    if (!vuln.metadata.tags) {
      vuln.metadata.tags = []
    }

    for (const tag of tags) {
      if (!vuln.metadata.tags.includes(tag)) {
        vuln.metadata.tags.push(tag)
      }
    }

    vuln.history.push({
      timestamp: new Date(),
      action: 'tagged',
      actor,
      comment: `Added tags: ${tags.join(', ')}`,
    })

    this.persistVulnerability(vuln)
    return vuln
  }

  // -------------------------------------------------------------------------
  // Query Methods
  // -------------------------------------------------------------------------

  /**
   * Get vulnerability by ID
   */
  getById(id: string): TrackedVulnerability | undefined {
    return this.vulnerabilities.get(id)
  }

  /**
   * Query vulnerabilities
   */
  query(options: VulnerabilityQuery = {}): VulnerabilityQueryResult {
    let results = Array.from(this.vulnerabilities.values())

    // Apply filters
    if (options.source && options.source.length > 0) {
      results = results.filter((v) => options.source!.includes(v.source))
    }

    if (options.severity && options.severity.length > 0) {
      results = results.filter((v) => options.severity!.includes(v.severity))
    }

    if (options.status && options.status.length > 0) {
      results = results.filter((v) => options.status!.includes(v.status))
    }

    if (options.priority && options.priority.length > 0) {
      results = results.filter((v) => options.priority!.includes(v.priority))
    }

    if (options.assignee) {
      results = results.filter((v) => v.remediation.assignee === options.assignee)
    }

    if (options.tags && options.tags.length > 0) {
      results = results.filter(
        (v) => v.metadata.tags && options.tags!.some((t) => v.metadata.tags!.includes(t))
      )
    }

    if (options.file) {
      results = results.filter((v) => v.location.file?.includes(options.file!))
    }

    if (options.package) {
      results = results.filter((v) => v.location.package?.includes(options.package!))
    }

    if (options.cve) {
      results = results.filter((v) => v.identifiers.cve === options.cve)
    }

    if (options.cwe) {
      results = results.filter(
        (v) => v.identifiers.cwe && v.identifiers.cwe.includes(options.cwe!)
      )
    }

    if (options.startDate) {
      results = results.filter((v) => v.metadata.firstSeen >= options.startDate!)
    }

    if (options.endDate) {
      results = results.filter((v) => v.metadata.firstSeen <= options.endDate!)
    }

    if (options.suppressed !== undefined) {
      results = results.filter((v) => v.metadata.suppressed === options.suppressed)
    }

    // Sort
    const sortBy = options.sortBy ?? 'severity'
    const sortOrder = options.sortOrder ?? 'desc'
    const multiplier = sortOrder === 'desc' ? -1 : 1

    results.sort((a, b) => {
      switch (sortBy) {
        case 'severity':
          return (SEVERITY_ORDER[a.severity] - SEVERITY_ORDER[b.severity]) * multiplier
        case 'priority':
          return (PRIORITY_ORDER[a.priority] - PRIORITY_ORDER[b.priority]) * multiplier
        case 'firstSeen':
          return (a.metadata.firstSeen.getTime() - b.metadata.firstSeen.getTime()) * multiplier
        case 'lastSeen':
          return (a.metadata.lastSeen.getTime() - b.metadata.lastSeen.getTime()) * multiplier
        case 'dueDate':
          const aDate = a.remediation.dueDate?.getTime() ?? Infinity
          const bDate = b.remediation.dueDate?.getTime() ?? Infinity
          return (aDate - bDate) * multiplier
        default:
          return 0
      }
    })

    // Pagination
    const total = results.length
    const offset = options.offset ?? 0
    const limit = options.limit ?? 100

    results = results.slice(offset, offset + limit)

    return {
      vulnerabilities: results,
      total,
      hasMore: offset + limit < total,
    }
  }

  /**
   * Get all open vulnerabilities
   */
  getOpen(): TrackedVulnerability[] {
    return this.query({
      status: ['open', 'acknowledged', 'in_progress'],
      suppressed: false,
    }).vulnerabilities
  }

  /**
   * Get overdue vulnerabilities
   */
  getOverdue(): TrackedVulnerability[] {
    const now = new Date()
    return this.getOpen().filter((v) => v.remediation.dueDate && v.remediation.dueDate < now)
  }

  /**
   * Get vulnerabilities by assignee
   */
  getByAssignee(assignee: string): TrackedVulnerability[] {
    return this.query({ assignee }).vulnerabilities
  }

  // -------------------------------------------------------------------------
  // Statistics
  // -------------------------------------------------------------------------

  /**
   * Get vulnerability statistics
   */
  getStats(): VulnerabilityStats {
    const all = Array.from(this.vulnerabilities.values())
    const open = all.filter(
      (v) => ['open', 'acknowledged', 'in_progress'].includes(v.status) && !v.metadata.suppressed
    )

    const stats: VulnerabilityStats = {
      total: all.length,
      bySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
      },
      byStatus: {
        open: 0,
        acknowledged: 0,
        in_progress: 0,
        fixed: 0,
        verified: 0,
        false_positive: 0,
        accepted_risk: 0,
        wont_fix: 0,
      },
      bySource: {
        sast: 0,
        dast: 0,
        sca: 0,
        manual: 0,
        pentest: 0,
        bugbounty: 0,
      },
      byPriority: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
      },
      overdueCount: 0,
      suppressedCount: all.filter((v) => v.metadata.suppressed).length,
    }

    for (const v of all) {
      stats.bySeverity[v.severity]++
      stats.byStatus[v.status]++
      stats.bySource[v.source]++
      stats.byPriority[v.priority]++
    }

    // Calculate overdue
    const now = new Date()
    stats.overdueCount = open.filter((v) => v.remediation.dueDate && v.remediation.dueDate < now).length

    // Find oldest open
    if (open.length > 0) {
      const oldest = open.reduce((min, v) =>
        v.metadata.firstSeen < min.metadata.firstSeen ? v : min
      )
      stats.oldestOpen = oldest.metadata.firstSeen
    }

    // Calculate MTTR (Mean Time to Remediation)
    const fixed = all.filter((v) => v.status === 'fixed' || v.status === 'verified')
    if (fixed.length > 0) {
      let totalTime = 0
      for (const v of fixed) {
        const fixedEntry = v.history.find(
          (h) => h.newStatus === 'fixed' || h.newStatus === 'verified'
        )
        if (fixedEntry) {
          totalTime += fixedEntry.timestamp.getTime() - v.metadata.firstSeen.getTime()
        }
      }
      stats.meanTimeToRemediation = totalTime / fixed.length
    }

    return stats
  }

  // -------------------------------------------------------------------------
  // Policy Enforcement
  // -------------------------------------------------------------------------

  /**
   * Check if deployment should be blocked based on policy
   */
  shouldBlockDeployment(): { blocked: boolean; reasons: string[] } {
    const stats = this.getStats()
    const reasons: string[] = []

    if (this.policy.blockOnCritical && stats.bySeverity.critical > this.policy.maxAllowed.critical) {
      reasons.push(
        `Critical vulnerabilities (${stats.bySeverity.critical}) exceed maximum allowed (${this.policy.maxAllowed.critical})`
      )
    }

    if (this.policy.blockOnHigh && stats.bySeverity.high > this.policy.maxAllowed.high) {
      reasons.push(
        `High vulnerabilities (${stats.bySeverity.high}) exceed maximum allowed (${this.policy.maxAllowed.high})`
      )
    }

    if (stats.bySeverity.medium > this.policy.maxAllowed.medium) {
      reasons.push(
        `Medium vulnerabilities (${stats.bySeverity.medium}) exceed maximum allowed (${this.policy.maxAllowed.medium})`
      )
    }

    return {
      blocked: reasons.length > 0,
      reasons,
    }
  }

  /**
   * Calculate SLA due date for a vulnerability
   */
  calculateDueDate(severity: UnifiedSeverity): Date {
    const days = this.policy.sla[severity === 'info' ? 'low' : severity]
    const dueDate = new Date()
    dueDate.setDate(dueDate.getDate() + days)
    return dueDate
  }

  /**
   * Get policy
   */
  getPolicy(): RemediationPolicy {
    return { ...this.policy }
  }

  /**
   * Update policy
   */
  updatePolicy(policy: Partial<RemediationPolicy>): void {
    this.policy = { ...this.policy, ...policy }
  }

  // -------------------------------------------------------------------------
  // Maintenance
  // -------------------------------------------------------------------------

  /**
   * Delete a vulnerability
   */
  delete(id: string): boolean {
    const vuln = this.vulnerabilities.get(id)
    if (!vuln) return false

    this.vulnerabilities.delete(id)
    this.hashIndex.delete(vuln.metadata.hash)

    if (this.config.onDelete) {
      this.config.onDelete(id).catch(() => {
        // Ignore persistence errors
      })
    }

    return true
  }

  /**
   * Clear all vulnerabilities
   */
  clear(): void {
    this.vulnerabilities.clear()
    this.hashIndex.clear()
  }

  /**
   * Get total count
   */
  get size(): number {
    return this.vulnerabilities.size
  }

  /**
   * Export all vulnerabilities
   */
  export(): TrackedVulnerability[] {
    return Array.from(this.vulnerabilities.values())
  }

  /**
   * Import vulnerabilities
   */
  import(vulnerabilities: TrackedVulnerability[]): void {
    for (const vuln of vulnerabilities) {
      this.addVulnerability(vuln)
    }
  }

  // -------------------------------------------------------------------------
  // Private Methods
  // -------------------------------------------------------------------------

  private addVulnerability(vuln: TrackedVulnerability): void {
    // Check for duplicates
    if (this.hashIndex.has(vuln.metadata.hash)) {
      return
    }

    // Check max limit
    if (this.vulnerabilities.size >= (this.config.maxVulnerabilities ?? 10000)) {
      throw new Error('Maximum vulnerability limit reached')
    }

    // Set SLA due date if not set
    if (!vuln.remediation.dueDate) {
      vuln.remediation.dueDate = this.calculateDueDate(vuln.severity)
    }

    this.vulnerabilities.set(vuln.id, vuln)
    this.hashIndex.set(vuln.metadata.hash, vuln.id)

    this.persistVulnerability(vuln)
  }

  private persistVulnerability(vuln: TrackedVulnerability): void {
    if (this.config.onPersist) {
      this.config.onPersist(vuln).catch(() => {
        // Ignore persistence errors
      })
    }
  }

  private isValidStatusTransition(from: VulnerabilityStatus, to: VulnerabilityStatus): boolean {
    const validTransitions: Record<VulnerabilityStatus, VulnerabilityStatus[]> = {
      open: ['acknowledged', 'in_progress', 'fixed', 'false_positive', 'accepted_risk', 'wont_fix'],
      acknowledged: ['in_progress', 'fixed', 'open', 'false_positive', 'accepted_risk', 'wont_fix'],
      in_progress: ['fixed', 'open', 'acknowledged', 'false_positive', 'accepted_risk', 'wont_fix'],
      fixed: ['verified', 'open'],
      verified: ['open'],
      false_positive: ['open'],
      accepted_risk: ['open'],
      wont_fix: ['open'],
    }

    return validTransitions[from]?.includes(to) ?? false
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a new vulnerability tracker
 */
export function createVulnerabilityTracker(
  config?: VulnerabilityTrackerConfig
): VulnerabilityTracker {
  return new VulnerabilityTracker(config)
}

/**
 * Create a vulnerability tracker for CI/CD pipelines
 */
export function createCIVulnerabilityTracker(): VulnerabilityTracker {
  return new VulnerabilityTracker({
    policy: {
      blockOnCritical: true,
      blockOnHigh: true,
      maxAllowed: {
        critical: 0,
        high: 0,
        medium: 10,
        low: 100,
      },
    },
  })
}

/**
 * Create a strict vulnerability tracker for production
 */
export function createStrictVulnerabilityTracker(): VulnerabilityTracker {
  return new VulnerabilityTracker({
    policy: {
      blockOnCritical: true,
      blockOnHigh: true,
      maxAllowed: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 10,
      },
      requireRiskAcceptanceJustification: true,
    },
  })
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Format vulnerability for display
 */
export function formatTrackedVulnerability(vuln: TrackedVulnerability): string {
  const parts = [
    `[${vuln.severity.toUpperCase()}] ${vuln.title}`,
    `  ID: ${vuln.id}`,
    `  Source: ${vuln.source}`,
    `  Status: ${vuln.status}`,
    `  Priority: ${vuln.priority}`,
  ]

  if (vuln.location.file) {
    parts.push(`  Location: ${vuln.location.file}:${vuln.location.line ?? '?'}`)
  }

  if (vuln.location.package) {
    parts.push(`  Package: ${vuln.location.package}@${vuln.location.version ?? '?'}`)
  }

  if (vuln.identifiers.cve) {
    parts.push(`  CVE: ${vuln.identifiers.cve}`)
  }

  if (vuln.remediation.assignee) {
    parts.push(`  Assignee: ${vuln.remediation.assignee}`)
  }

  if (vuln.remediation.dueDate) {
    parts.push(`  Due: ${vuln.remediation.dueDate.toISOString().split('T')[0]}`)
  }

  return parts.join('\n')
}

/**
 * Format stats for display
 */
export function formatVulnerabilityStats(stats: VulnerabilityStats): string {
  return [
    '# Vulnerability Statistics',
    '',
    `Total: ${stats.total}`,
    '',
    '## By Severity',
    `- Critical: ${stats.bySeverity.critical}`,
    `- High: ${stats.bySeverity.high}`,
    `- Medium: ${stats.bySeverity.medium}`,
    `- Low: ${stats.bySeverity.low}`,
    `- Info: ${stats.bySeverity.info}`,
    '',
    '## By Status',
    `- Open: ${stats.byStatus.open}`,
    `- Acknowledged: ${stats.byStatus.acknowledged}`,
    `- In Progress: ${stats.byStatus.in_progress}`,
    `- Fixed: ${stats.byStatus.fixed}`,
    `- Verified: ${stats.byStatus.verified}`,
    `- False Positive: ${stats.byStatus.false_positive}`,
    `- Accepted Risk: ${stats.byStatus.accepted_risk}`,
    '',
    '## Metrics',
    `- Overdue: ${stats.overdueCount}`,
    `- Suppressed: ${stats.suppressedCount}`,
    stats.meanTimeToRemediation
      ? `- Mean Time to Remediation: ${Math.round(stats.meanTimeToRemediation / (1000 * 60 * 60 * 24))} days`
      : '',
  ].join('\n')
}

/**
 * Generate a remediation report
 */
export function generateRemediationReport(tracker: VulnerabilityTracker): string {
  const stats = tracker.getStats()
  const open = tracker.getOpen()
  const overdue = tracker.getOverdue()
  const blockStatus = tracker.shouldBlockDeployment()

  const lines = [
    '# Vulnerability Remediation Report',
    `Generated: ${new Date().toISOString()}`,
    '',
    `## Deployment Status: ${blockStatus.blocked ? 'BLOCKED' : 'ALLOWED'}`,
  ]

  if (blockStatus.reasons.length > 0) {
    lines.push('', '### Block Reasons:')
    for (const reason of blockStatus.reasons) {
      lines.push(`- ${reason}`)
    }
  }

  lines.push('', formatVulnerabilityStats(stats))

  if (overdue.length > 0) {
    lines.push('', '## Overdue Vulnerabilities', '')
    for (const vuln of overdue.slice(0, 10)) {
      lines.push(formatTrackedVulnerability(vuln), '')
    }
    if (overdue.length > 10) {
      lines.push(`... and ${overdue.length - 10} more`)
    }
  }

  if (open.filter((v) => v.severity === 'critical').length > 0) {
    lines.push('', '## Critical Vulnerabilities', '')
    for (const vuln of open.filter((v) => v.severity === 'critical')) {
      lines.push(formatTrackedVulnerability(vuln), '')
    }
  }

  return lines.join('\n')
}
