/**
 * Vulnerability Tracker Tests
 */

import {
  VulnerabilityTracker,
  createVulnerabilityTracker,
  createCIVulnerabilityTracker,
  createStrictVulnerabilityTracker,
  DEFAULT_REMEDIATION_POLICY,
  formatTrackedVulnerability,
  formatVulnerabilityStats,
  generateRemediationReport,
  type TrackedVulnerability,
  type VulnerabilityStatus,
  type UnifiedSeverity,
  type VulnerabilitySource,
} from '../vulnerability-tracker'
import type { SASTFinding } from '../sast-scanner'
import type { DependencyVulnerability } from '../dependency-scanner'

describe('Vulnerability Tracker', () => {
  // =========================================================================
  // Tracker Creation
  // =========================================================================
  describe('Tracker Creation', () => {
    it('creates tracker with default configuration', () => {
      const tracker = createVulnerabilityTracker()
      expect(tracker).toBeInstanceOf(VulnerabilityTracker)
      expect(tracker.size).toBe(0)
    })

    it('creates tracker with custom policy', () => {
      const tracker = createVulnerabilityTracker({
        policy: {
          blockOnCritical: false,
          maxAllowed: { critical: 5, high: 10, medium: 50, low: 100 },
        },
      })
      const policy = tracker.getPolicy()
      expect(policy.blockOnCritical).toBe(false)
      expect(policy.maxAllowed.critical).toBe(5)
    })

    it('creates CI tracker with appropriate settings', () => {
      const tracker = createCIVulnerabilityTracker()
      const policy = tracker.getPolicy()
      expect(policy.blockOnCritical).toBe(true)
      expect(policy.blockOnHigh).toBe(true)
    })

    it('creates strict tracker for production', () => {
      const tracker = createStrictVulnerabilityTracker()
      const policy = tracker.getPolicy()
      expect(policy.maxAllowed.medium).toBe(0)
      expect(policy.requireRiskAcceptanceJustification).toBe(true)
    })
  })

  // =========================================================================
  // Import SAST Findings
  // =========================================================================
  describe('Import SAST Findings', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
    })

    it('imports SAST finding as tracked vulnerability', () => {
      const finding: SASTFinding = {
        id: 'finding-1',
        ruleId: 'SAST001',
        ruleName: 'SQL Injection',
        severity: 'critical',
        category: 'injection',
        file: 'src/api.ts',
        line: 42,
        snippet: 'pool.query(`SELECT ${id}`)',
        description: 'SQL injection detected',
        cwe: 'CWE-89',
        owasp: 'A03:2021',
        remediation: 'Use parameterized queries',
        timestamp: new Date(),
        hash: 'abc123',
      }

      const vuln = tracker.importSASTFinding(finding)

      expect(vuln.source).toBe('sast')
      expect(vuln.severity).toBe('critical')
      expect(vuln.status).toBe('open')
      expect(vuln.location.file).toBe('src/api.ts')
      expect(vuln.location.line).toBe(42)
      expect(tracker.size).toBe(1)
    })

    it('deduplicates identical SAST findings', () => {
      const finding: SASTFinding = {
        id: 'finding-1',
        ruleId: 'SAST001',
        ruleName: 'SQL Injection',
        severity: 'critical',
        category: 'injection',
        file: 'src/api.ts',
        line: 42,
        snippet: 'test',
        description: 'Test',
        remediation: 'Fix it',
        timestamp: new Date(),
        hash: 'same',
      }

      tracker.importSASTFinding(finding)
      tracker.importSASTFinding(finding)

      expect(tracker.size).toBe(1)
    })

    it('updates lastSeen on duplicate import', () => {
      const finding: SASTFinding = {
        id: 'finding-1',
        ruleId: 'SAST001',
        ruleName: 'SQL Injection',
        severity: 'critical',
        category: 'injection',
        file: 'src/api.ts',
        line: 42,
        snippet: 'test',
        description: 'Test',
        remediation: 'Fix it',
        timestamp: new Date(),
        hash: 'same',
      }

      const firstImport = tracker.importSASTFinding(finding)
      const firstLastSeen = firstImport.metadata.lastSeen

      // Wait a bit
      const secondImport = tracker.importSASTFinding(finding)

      expect(secondImport.metadata.lastSeen.getTime()).toBeGreaterThanOrEqual(
        firstLastSeen.getTime()
      )
    })
  })

  // =========================================================================
  // Import Dependency Vulnerabilities
  // =========================================================================
  describe('Import Dependency Vulnerabilities', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
    })

    it('imports dependency vulnerability as tracked vulnerability', () => {
      const depVuln: DependencyVulnerability = {
        id: 'vuln-1',
        advisoryId: 'GHSA-1234',
        packageName: 'lodash',
        packageVersion: '4.17.19',
        ecosystem: 'npm',
        severity: 'critical',
        title: 'Prototype Pollution',
        description: 'Test description',
        cve: 'CVE-2021-23337',
        cwe: ['CWE-1321'],
        affectedVersions: '<4.17.21',
        patchedVersions: '>=4.17.21',
        recommendation: 'Upgrade lodash',
        references: [],
      }

      const vuln = tracker.importDependencyVulnerability(depVuln)

      expect(vuln.source).toBe('sca')
      expect(vuln.severity).toBe('critical')
      expect(vuln.location.package).toBe('lodash')
      expect(vuln.location.version).toBe('4.17.19')
      expect(vuln.remediation.patchAvailable).toBe(true)
    })

    it('normalizes moderate severity to medium', () => {
      const depVuln: DependencyVulnerability = {
        id: 'vuln-1',
        advisoryId: 'GHSA-1234',
        packageName: 'test',
        packageVersion: '1.0.0',
        ecosystem: 'npm',
        severity: 'moderate',
        title: 'Test',
        description: 'Test',
        affectedVersions: '<2.0.0',
        recommendation: 'Upgrade',
        references: [],
      }

      const vuln = tracker.importDependencyVulnerability(depVuln)

      expect(vuln.severity).toBe('medium')
    })
  })

  // =========================================================================
  // Import Manual Findings
  // =========================================================================
  describe('Import Manual Findings', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
    })

    it('imports manual findings', () => {
      const vuln = tracker.importManualFinding({
        title: 'Manual Finding',
        description: 'Found during code review',
        severity: 'high',
        location: { file: 'src/auth.ts', line: 100 },
        tags: ['code-review'],
      })

      expect(vuln.source).toBe('manual')
      expect(vuln.title).toBe('Manual Finding')
      expect(vuln.metadata.tags).toContain('code-review')
    })

    it('supports different sources', () => {
      const pentest = tracker.importManualFinding({
        title: 'Pentest Finding',
        description: 'Found during penetration test',
        severity: 'critical',
        source: 'pentest',
      })

      expect(pentest.source).toBe('pentest')
    })
  })

  // =========================================================================
  // Status Management
  // =========================================================================
  describe('Status Management', () => {
    let tracker: VulnerabilityTracker
    let vulnId: string

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
      const vuln = tracker.importManualFinding({
        title: 'Test Vulnerability',
        description: 'Test',
        severity: 'high',
      })
      vulnId = vuln.id
    })

    it('updates vulnerability status', () => {
      const updated = tracker.updateStatus(vulnId, 'acknowledged', 'admin')

      expect(updated?.status).toBe('acknowledged')
      expect(updated?.history.length).toBeGreaterThan(1)
    })

    it('records status change in history', () => {
      tracker.updateStatus(vulnId, 'in_progress', 'developer')
      const vuln = tracker.getById(vulnId)

      const statusChange = vuln?.history.find((h) => h.action === 'status_changed')
      expect(statusChange).toBeDefined()
      expect(statusChange?.previousStatus).toBe('open')
      expect(statusChange?.newStatus).toBe('in_progress')
      expect(statusChange?.actor).toBe('developer')
    })

    it('rejects invalid status transitions', () => {
      // Verified -> acknowledged is not valid
      tracker.updateStatus(vulnId, 'fixed')
      tracker.updateStatus(vulnId, 'verified')

      expect(() => {
        tracker.updateStatus(vulnId, 'acknowledged')
      }).toThrow()
    })

    it('returns null for non-existent vulnerability', () => {
      const result = tracker.updateStatus('nonexistent', 'acknowledged')
      expect(result).toBeNull()
    })
  })

  // =========================================================================
  // Assignment
  // =========================================================================
  describe('Assignment', () => {
    let tracker: VulnerabilityTracker
    let vulnId: string

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'medium',
      })
      vulnId = vuln.id
    })

    it('assigns vulnerability to user', () => {
      const updated = tracker.assignTo(vulnId, 'developer@example.com', 'manager')

      expect(updated?.remediation.assignee).toBe('developer@example.com')
    })

    it('records assignment in history', () => {
      tracker.assignTo(vulnId, 'developer@example.com')
      const vuln = tracker.getById(vulnId)

      const assignment = vuln?.history.find((h) => h.action === 'assigned')
      expect(assignment).toBeDefined()
    })
  })

  // =========================================================================
  // Due Dates
  // =========================================================================
  describe('Due Dates', () => {
    let tracker: VulnerabilityTracker
    let vulnId: string

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'high',
      })
      vulnId = vuln.id
    })

    it('sets due date', () => {
      const dueDate = new Date('2025-12-31')
      const updated = tracker.setDueDate(vulnId, dueDate)

      expect(updated?.remediation.dueDate?.toISOString()).toBe(dueDate.toISOString())
    })

    it('calculates SLA-based due dates', () => {
      const dueDate = tracker.calculateDueDate('critical')
      const expectedDate = new Date()
      expectedDate.setDate(expectedDate.getDate() + DEFAULT_REMEDIATION_POLICY.sla.critical)

      // Allow 1 day tolerance for timing
      expect(Math.abs(dueDate.getTime() - expectedDate.getTime())).toBeLessThan(86400000)
    })

    it('automatically sets due date on import', () => {
      const vuln = tracker.getById(vulnId)
      expect(vuln?.remediation.dueDate).toBeDefined()
    })
  })

  // =========================================================================
  // Suppression
  // =========================================================================
  describe('Suppression', () => {
    let tracker: VulnerabilityTracker
    let vulnId: string

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'low',
      })
      vulnId = vuln.id
    })

    it('suppresses vulnerability as false positive', () => {
      const updated = tracker.suppress(vulnId, 'Not applicable', 'false_positive', 'security')

      expect(updated?.status).toBe('false_positive')
      expect(updated?.metadata.suppressed).toBe(true)
      expect(updated?.metadata.suppressedBy).toBe('security')
    })

    it('suppresses vulnerability as accepted risk', () => {
      const updated = tracker.suppress(
        vulnId,
        'Risk accepted due to mitigating controls',
        'accepted_risk',
        'ciso'
      )

      expect(updated?.status).toBe('accepted_risk')
      expect(updated?.metadata.suppressionReason).toBe('Risk accepted due to mitigating controls')
    })

    it('requires justification for accepted risk when policy requires it', () => {
      const strictTracker = createStrictVulnerabilityTracker()
      const vuln = strictTracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'medium',
      })

      expect(() => {
        strictTracker.suppress(vuln.id, '', 'accepted_risk', 'user')
      }).toThrow()
    })

    it('unsuppresses vulnerability', () => {
      tracker.suppress(vulnId, 'Test', 'false_positive', 'user')
      const updated = tracker.unsuppress(vulnId, 'admin')

      expect(updated?.status).toBe('open')
      expect(updated?.metadata.suppressed).toBe(false)
    })
  })

  // =========================================================================
  // Notes and Tags
  // =========================================================================
  describe('Notes and Tags', () => {
    let tracker: VulnerabilityTracker
    let vulnId: string

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'medium',
      })
      vulnId = vuln.id
    })

    it('adds notes to vulnerability', () => {
      tracker.addNote(vulnId, 'This needs attention', 'developer')
      const vuln = tracker.getById(vulnId)

      expect(vuln?.metadata.notes?.length).toBe(1)
      expect(vuln?.metadata.notes?.[0]).toContain('This needs attention')
    })

    it('adds tags to vulnerability', () => {
      tracker.addTags(vulnId, ['priority', 'sprint-5'])
      const vuln = tracker.getById(vulnId)

      expect(vuln?.metadata.tags).toContain('priority')
      expect(vuln?.metadata.tags).toContain('sprint-5')
    })

    it('does not duplicate tags', () => {
      tracker.addTags(vulnId, ['tag1'])
      tracker.addTags(vulnId, ['tag1', 'tag2'])
      const vuln = tracker.getById(vulnId)

      expect(vuln?.metadata.tags?.filter((t) => t === 'tag1').length).toBe(1)
    })
  })

  // =========================================================================
  // Querying
  // =========================================================================
  describe('Querying', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()

      // Add various vulnerabilities
      tracker.importManualFinding({
        title: 'Critical Vuln',
        description: 'Test',
        severity: 'critical',
        source: 'sast',
        tags: ['api'],
      })
      tracker.importManualFinding({
        title: 'High Vuln',
        description: 'Test',
        severity: 'high',
        source: 'sca',
      })
      tracker.importManualFinding({
        title: 'Medium Vuln',
        description: 'Test',
        severity: 'medium',
        source: 'manual',
      })
    })

    it('queries all vulnerabilities', () => {
      const result = tracker.query()
      expect(result.total).toBe(3)
    })

    it('filters by severity', () => {
      const result = tracker.query({ severity: ['critical', 'high'] })
      expect(result.total).toBe(2)
    })

    it('filters by source', () => {
      const result = tracker.query({ source: ['sast'] })
      expect(result.total).toBe(1)
    })

    it('filters by status', () => {
      const result = tracker.query({ status: ['open'] })
      expect(result.total).toBe(3)
    })

    it('filters by tags', () => {
      const result = tracker.query({ tags: ['api'] })
      expect(result.total).toBe(1)
    })

    it('filters by suppressed', () => {
      const result = tracker.query({ suppressed: false })
      expect(result.total).toBe(3)
    })

    it('applies pagination', () => {
      const result = tracker.query({ limit: 2, offset: 0 })
      expect(result.vulnerabilities.length).toBe(2)
      expect(result.hasMore).toBe(true)
    })

    it('sorts by severity', () => {
      const result = tracker.query({ sortBy: 'severity', sortOrder: 'desc' })
      expect(result.vulnerabilities[0].severity).toBe('critical')
    })

    it('gets open vulnerabilities', () => {
      const open = tracker.getOpen()
      expect(open.length).toBe(3)
    })
  })

  // =========================================================================
  // Statistics
  // =========================================================================
  describe('Statistics', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()

      // Use unique locations to avoid deduplication
      tracker.importManualFinding({
        title: 'Vuln 1',
        description: 'Test critical',
        severity: 'critical',
        location: { file: 'file1.ts', line: 1 },
      })
      tracker.importManualFinding({
        title: 'Vuln 2',
        description: 'Test high',
        severity: 'high',
        location: { file: 'file2.ts', line: 2 },
      })
      tracker.importManualFinding({
        title: 'Vuln 3',
        description: 'Test medium',
        severity: 'medium',
        location: { file: 'file3.ts', line: 3 },
      })
    })

    it('calculates statistics correctly', () => {
      const stats = tracker.getStats()

      expect(stats.total).toBe(3)
      expect(stats.bySeverity.critical).toBe(1)
      expect(stats.bySeverity.high).toBe(1)
      expect(stats.bySeverity.medium).toBe(1)
      expect(stats.byStatus.open).toBe(3)
    })

    it('tracks overdue count', () => {
      // Set a past due date
      const vulns = tracker.getOpen()
      if (vulns.length > 0) {
        const pastDate = new Date()
        pastDate.setDate(pastDate.getDate() - 10)
        tracker.setDueDate(vulns[0].id, pastDate)
      }

      const stats = tracker.getStats()
      expect(stats.overdueCount).toBe(1)
    })

    it('tracks suppressed count', () => {
      const vulns = tracker.getOpen()
      if (vulns.length > 0) {
        tracker.suppress(vulns[0].id, 'Test', 'false_positive', 'user')
      }

      const stats = tracker.getStats()
      expect(stats.suppressedCount).toBe(1)
    })
  })

  // =========================================================================
  // Policy Enforcement
  // =========================================================================
  describe('Policy Enforcement', () => {
    it('blocks deployment on critical vulnerabilities', () => {
      const tracker = createVulnerabilityTracker()

      tracker.importManualFinding({
        title: 'Critical',
        description: 'Test',
        severity: 'critical',
      })

      const blockStatus = tracker.shouldBlockDeployment()

      expect(blockStatus.blocked).toBe(true)
      expect(blockStatus.reasons.length).toBeGreaterThan(0)
    })

    it('blocks deployment on high vulnerabilities', () => {
      const tracker = createVulnerabilityTracker()

      tracker.importManualFinding({
        title: 'High',
        description: 'Test',
        severity: 'high',
      })

      const blockStatus = tracker.shouldBlockDeployment()

      expect(blockStatus.blocked).toBe(true)
    })

    it('allows deployment with only medium/low vulnerabilities', () => {
      const tracker = createVulnerabilityTracker()

      tracker.importManualFinding({
        title: 'Medium',
        description: 'Test',
        severity: 'medium',
      })

      const blockStatus = tracker.shouldBlockDeployment()

      expect(blockStatus.blocked).toBe(false)
    })

    it('blocks when exceeding medium threshold', () => {
      const tracker = createVulnerabilityTracker({
        policy: { maxAllowed: { critical: 0, high: 0, medium: 2, low: 10 } },
      })

      for (let i = 0; i < 5; i++) {
        tracker.importManualFinding({
          title: `Medium ${i}`,
          description: `Test medium vulnerability ${i}`,
          severity: 'medium',
          location: { file: `file${i}.ts`, line: i + 1 },
        })
      }

      const blockStatus = tracker.shouldBlockDeployment()

      expect(blockStatus.blocked).toBe(true)
    })

    it('updates policy', () => {
      const tracker = createVulnerabilityTracker()

      tracker.updatePolicy({ blockOnHigh: false })

      expect(tracker.getPolicy().blockOnHigh).toBe(false)
    })
  })

  // =========================================================================
  // Maintenance
  // =========================================================================
  describe('Maintenance', () => {
    let tracker: VulnerabilityTracker

    beforeEach(() => {
      tracker = createVulnerabilityTracker()
    })

    it('deletes vulnerability', () => {
      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'low',
      })

      const deleted = tracker.delete(vuln.id)

      expect(deleted).toBe(true)
      expect(tracker.size).toBe(0)
    })

    it('returns false for deleting non-existent vulnerability', () => {
      const deleted = tracker.delete('nonexistent')
      expect(deleted).toBe(false)
    })

    it('clears all vulnerabilities', () => {
      tracker.importManualFinding({ title: 'Test 1', description: 'Test', severity: 'low' })
      tracker.importManualFinding({ title: 'Test 2', description: 'Test', severity: 'low' })

      tracker.clear()

      expect(tracker.size).toBe(0)
    })

    it('exports vulnerabilities', () => {
      tracker.importManualFinding({ title: 'Test', description: 'Test', severity: 'low' })

      const exported = tracker.export()

      expect(exported.length).toBe(1)
    })

    it('imports vulnerabilities', () => {
      const vulns: TrackedVulnerability[] = [
        {
          id: 'imported-1',
          source: 'manual',
          severity: 'medium',
          status: 'open',
          priority: 'medium',
          title: 'Imported',
          description: 'Test',
          location: {},
          identifiers: {},
          remediation: { recommendation: 'Fix' },
          metadata: {
            hash: 'unique',
            firstSeen: new Date(),
            lastSeen: new Date(),
          },
          history: [],
        },
      ]

      tracker.import(vulns)

      expect(tracker.size).toBe(1)
    })
  })

  // =========================================================================
  // Utility Functions
  // =========================================================================
  describe('Utility Functions', () => {
    describe('formatTrackedVulnerability', () => {
      it('formats vulnerability for display', () => {
        const vuln: TrackedVulnerability = {
          id: 'test-1',
          source: 'sast',
          severity: 'critical',
          status: 'open',
          priority: 'critical',
          title: 'SQL Injection',
          description: 'Test',
          location: { file: 'api.ts', line: 42 },
          identifiers: { cve: 'CVE-2021-1234' },
          remediation: { recommendation: 'Fix', assignee: 'dev@example.com' },
          metadata: {
            hash: 'abc',
            firstSeen: new Date(),
            lastSeen: new Date(),
          },
          history: [],
        }

        const formatted = formatTrackedVulnerability(vuln)

        expect(formatted).toContain('[CRITICAL]')
        expect(formatted).toContain('SQL Injection')
        expect(formatted).toContain('api.ts:42')
        expect(formatted).toContain('CVE-2021-1234')
      })
    })

    describe('formatVulnerabilityStats', () => {
      it('formats statistics for display', () => {
        const tracker = createVulnerabilityTracker()
        tracker.importManualFinding({
          title: 'Test',
          description: 'Test',
          severity: 'high',
        })

        const stats = tracker.getStats()
        const formatted = formatVulnerabilityStats(stats)

        expect(formatted).toContain('# Vulnerability Statistics')
        expect(formatted).toContain('Total: 1')
        expect(formatted).toContain('High: 1')
      })
    })

    describe('generateRemediationReport', () => {
      it('generates comprehensive report', () => {
        const tracker = createVulnerabilityTracker()
        tracker.importManualFinding({
          title: 'Critical Issue',
          description: 'Test',
          severity: 'critical',
        })

        const report = generateRemediationReport(tracker)

        expect(report).toContain('# Vulnerability Remediation Report')
        expect(report).toContain('BLOCKED')
        expect(report).toContain('Critical Vulnerabilities')
      })
    })
  })

  // =========================================================================
  // Default Policy
  // =========================================================================
  describe('Default Policy', () => {
    it('has sensible default values', () => {
      expect(DEFAULT_REMEDIATION_POLICY.blockOnCritical).toBe(true)
      expect(DEFAULT_REMEDIATION_POLICY.blockOnHigh).toBe(true)
      expect(DEFAULT_REMEDIATION_POLICY.maxAllowed.critical).toBe(0)
      expect(DEFAULT_REMEDIATION_POLICY.maxAllowed.high).toBe(0)
      expect(DEFAULT_REMEDIATION_POLICY.sla.critical).toBe(1)
      expect(DEFAULT_REMEDIATION_POLICY.sla.high).toBe(7)
    })
  })

  // =========================================================================
  // Persistence Callbacks
  // =========================================================================
  describe('Persistence Callbacks', () => {
    it('calls onPersist when vulnerability is added', async () => {
      const onPersist = jest.fn().mockResolvedValue(undefined)
      const tracker = createVulnerabilityTracker({ onPersist })

      tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'low',
      })

      await new Promise((resolve) => setTimeout(resolve, 10))

      expect(onPersist).toHaveBeenCalled()
    })

    it('calls onDelete when vulnerability is deleted', async () => {
      const onDelete = jest.fn().mockResolvedValue(undefined)
      const tracker = createVulnerabilityTracker({ onDelete })

      const vuln = tracker.importManualFinding({
        title: 'Test',
        description: 'Test',
        severity: 'low',
      })

      tracker.delete(vuln.id)

      await new Promise((resolve) => setTimeout(resolve, 10))

      expect(onDelete).toHaveBeenCalledWith(vuln.id)
    })
  })
})
